---
title: "无刻度容器倒水问题"
date: 2023-01-24T05:06:27+08:00
draft: false
---

# 问题背景
往年春节都太多计划、太多想做的事情，结果都是各种懊恼……今年春节打算静下来心做一点很小很小的事情。
忽然想起2016年5、6月份找实习时，被问到的一个“智力题”：
> 有三个无刻度的容器，一个10L装满水，另外两个是空的，容积分别是3L、7L，问如何得到各5L的水？

因为当时大三，刚好学过人工智能、搜索算法这些，当时第一想法就是，这不直接搜一遍就好嘛，倒水就是个“状态转移”的过程。但说出来好像电话那头不太满意，让我说确切的答案……只能硬着头皮算，磕磕碰碰还是给出了答案：
> 10、3、7，要平分成5，关键是能够凑出一个2。然后……灵光一闪，3*3-7不就是2吗（这里大概靠数字敏感直觉之类的吧），然后就说10往3里倒满、3再往7里倒，重复到第3次时，3L的容器里就剩2L的水了，然后答案显然可得。

今天想把那个正式的搜索思路给实现一下，算是close掉这个事情，顺便也开启独立站点的第一篇正式博客。

温馨提示：阅读以下内容要求你至少具备这些知识——
- 宽度优先搜索算法
- 队列/栈/树等基础数据结构
- C++编程基础


# 抽象一下问题
给定初始状态S0、目标状态SN，求(最短)路径。

举个例子，初始状态为(10L, 0L, 0L)，如果10L往3L容器里倒满水，则状态变成(7L, 3L, 0L)，两者之间有一条路径。

## 状态该如何表示？
像上述例子，如果只用“当前装水的量”来表示状态的话，会丢失容积信息，导致状态转移时没法计算“谁可以往谁倒多少”，所以单个容器的状态表示应该为：
```C++
// state.h
// 单个容器的状态
struct ContainerState {
  int volume;        // 容器本身的固有容积
  int water_volume;  // 容器当前储水的体积
};
```

而搜索树上单个结点的状态，由M个容器组成，其中M可能大于3个，可以用一个数组来表示：
```C++
// state.h
// 单个结点的状态
struct NodeState {
  std::vector<ContainerState> states;
};
```

进而，整个问题求解可以这样子表示：
```C++
// solution.cpp
#include "state.h"

void Solve(const NodeState& start, const NodeState& target);

int main() {
  NodeState start{.states = {{10, 10}, {7, 0}, {3, 0}}};
  NodeState target{.states = {{10, 5}, {7, 5}, {3, 0}}};
  Solve(start, target);
  return 0;
}

void Solve(const NodeState& start, const NodeState& target) {
    // TODO: 实现搜索过程
}
```

# 分解问题
## 搭搜索过程的代码框架
首先，搜索算法选择，这里打算选用BFS而非DFS，因为：BFS可以高效率地找到最优解（如果有）。

典型的BFS搜索框架为：
```C++
void Solve(const NodeState& start, const NodeState& target) {
    // 1、根据初始状态来初始化队列
    queue<NodeState> state_queue;
    state_queue.push(start);

    // 2、出队、尝试转移到新的结点
    while (!state_queue.empty()) {
        // 2.1、出队
        NodeState curr_state = state_queue.front();
        state_queue.pop();

        // 2.2、尝试转移状态

        // 2.3、判断是否转移到目标状态了，是则可以退出了

        // 2.4、判断新结点是否重复，不重复才允许加入队列
    }

    // 3、队列出空还未找到有效路径，则判定为无解
    cout << "No solution..." << endl;
}
```

## 如何转移状态？
在这个问题里，由于容器是无刻度的，所以合法的倒水方式只能是这两种：
- 从A倒给B，直到B已满；
- 从A倒给B，直到A没水了。

那A和B分别可以是谁呢？还是以三个容器ABC为例，可能的倒水排列组合为：A->B, A->C, B->A, B->C, C->A, C->B。
其实就是所有容器里选两个的排列，那状态转移过程就容易写了。最笨的方法就是两重循环，枚举排列：

```C++
void Solve(const NodeState& start, const NodeState& target) {
  // 1、根据初始状态来初始化队列
  queue<NodeState> state_queue;
  state_queue.push(start);

  // 2、出队、尝试转移到新的结点
  while (!state_queue.empty()) {
    // 2.1、出队
    NodeState curr_state = state_queue.front();
    state_queue.pop();

    // 2.2、尝试转移状态
    for (size_t i = 0; i < curr_state.states.size(); ++i) {
      for (size_t j = 0; j < curr_state.states.size(); ++j) {
        if (i == j) continue;                                // 自己不能倒给自己
        int self_water = curr_state.states[i].water_volume;  // 自身有的水量
        int can_accept_water = curr_state.states[j].volume - curr_state.states[j].water_volume;  // 对方可接收的水量
        int poll_water = min(self_water, can_accept_water);                                      // 本次可倒的水
        if (poll_water == 0) continue;

        NodeState new_state = curr_state;
        new_state.states[i].water_volume -= poll_water;
        new_state.states[j].water_volume += poll_water;
        // 2.3、判断是否转移到目标状态了，是则可以退出了

        // 2.4、判断新结点是否重复，不重复才允许加入队列
      }
    }
  }

  // 3、队列出空还未找到有效路径，则判定为无解
  cout << "No solution..." << endl;
}
```

## 如何判定是否为目标状态？
这个最简单的，就依次判断各个容器的水量跟目标状态的是否一致即可。考虑这个是NodeState本身的比较逻辑，所以写成NodeState的方法会更合适，在C++里则还可以重载一下==符号，更加直观易懂。

```C++
// state.h
// 单个结点的状态
// 温馨提示：这里用了assert是会导致程序直接退出的。若是线上服务，最好用可降级的报错方式。
struct NodeState {
  std::vector<ContainerState> states;

  bool operator==(const NodeState& other) const {
    assert(states.size() == other.states.size());  // 限制结点的容器数量必须相等，才允许比较
    for (size_t i = 0; i < states.size(); ++i) {
      assert(states[i].volume == other.states[i].volume);  // 限制容积相等的容器对齐比较
      if (states[i].water_volume != other.states[i].water_volume) return false;
    }
    return true;
  }
};
```

## 如何判断结点是否重复？
最简单的就是把所有**入过**队列的结点放到一个集合里，然后查找判重即可。
考虑到后边还要复原整个转移路径，所以这里选择用map来存放状态转移记录，而非用set。

注意map内部会对元素做大小比较的，但由于NodeState是自定义的类型，STL判断大小时，不知道该怎么办……所以还需要指定其`operator<`的行为：

```C++
// state.h
// 单个结点的状态
// 温馨提示：这里用了assert是会导致程序直接退出的。若是线上服务，最好用可降级的报错方式。
struct NodeState {
  std::vector<ContainerState> states;

  bool operator==(const NodeState& other) const {
    assert(states.size() == other.states.size());  // 限制结点的容器数量必须相等，才允许比较
    for (size_t i = 0; i < states.size(); ++i) {
      assert(states[i].volume == other.states[i].volume);  // 限制容积相等的容器对齐比较
      if (states[i].water_volume != other.states[i].water_volume) return false;
    }
    return true;
  }

  bool operator<(const NodeState& other) const {
    assert(states.size() > 0);                     // 限制非空状态
    assert(states.size() == other.states.size());  // 限制结点的容器数量必须相等，才允许比较
    for (size_t i = 0; i < states.size(); ++i) {
      assert(states[i].volume == other.states[i].volume);  // 限制容积相等的容器对齐比较
      if (states[i].water_volume != other.states[i].water_volume) {
        return states[i].water_volume < other.states[i].water_volume;
      }
    }
    return false;
  }
};
```

```C++
// solution.cpp
void Solve(const NodeState& start, const NodeState& target) {
  // 1、根据初始状态来初始化队列
  queue<NodeState> state_queue;
  state_queue.push(start);
  map<NodeState, NodeState> visit_records;

  // 2、出队、尝试转移到新的结点
  while (!state_queue.empty()) {
    // 2.1、出队
    NodeState curr_state = state_queue.front();
    state_queue.pop();

    // 2.2、尝试转移状态
    for (size_t i = 0; i < curr_state.states.size(); ++i) {
      for (size_t j = 0; j < curr_state.states.size(); ++j) {
        if (i == j) continue;                                // 自己不能倒给自己
        int self_water = curr_state.states[i].water_volume;  // 自身有的水量
        int can_accept_water = curr_state.states[j].volume - curr_state.states[j].water_volume;  // 对方可接收的水量
        int poll_water = min(self_water, can_accept_water);                                      // 本次可倒的水
        if (poll_water == 0) continue;

        NodeState new_state = curr_state;
        new_state.states[i].water_volume -= poll_water;
        new_state.states[j].water_volume += poll_water;
        // 2.3、判断是否转移到目标状态了，是则可以退出了
        if (new_state == target) {
            // TODO: 打印转移路径
            return;
        }

        // 2.4、判断新结点是否重复，不重复才允许加入队列
        if (visit_records.find(new_state) == visit_records.end()) {
          visit_records[new_state] = curr_state;
          state_queue.push(new_state);
        }
      }
    }
  }

  // 3、队列出空还未找到有效路径，则判定为无解
  cout << "No solution..." << endl;
}
```

## 如何打印转移路径？
状态从A到B转移的过程，我们记录的是B->A的映射，方向是相反的，所以需要有一个反推的过程，用栈或数组记录一下，然后按反推后的顺序输出即可：

```C++
void PrintSolution(const map<NodeState, NodeState>& visit_records, const NodeState& start, const NodeState& target) {
    NodeState curr_state = target;
    stack<NodeState> solution;
    while (!(curr_state == start)) {
        solution.push(curr_state);
        auto iter = visit_records.find(curr_state);
        // 注：这里一定能反推回去，除非代码写错了
        if (iter == visit_records.end()) {
            cout << "backtrace solution fail, your code is wrong..." << endl;
            exit(-1);
        } else {
            curr_state = iter->second;
        }
    }

    cout << "Found out solution:" << endl;
    while (!solution.empty()) {
        cout << solution.top() << endl;
        solution.pop();
    }
}
```

# 测试验证
程序能跑起来，也能就这个case输出正确的结果，但真的写对了吗？写完整了吗？这些问题留给读者继续思考哈。

# 结语
从上边可以看出，先定义清楚问题，把主框架搭出来后，程序层次会清晰很多。我现在是很享受这种写代码方式的，层层递进。

另外我一直不太清楚面试考察“智力题”的真实目的，有人说就纯粹看人的聪明度，也有说是看“面对非模式化问题时的临场反应，考察思考习惯、头脑活跃度、抗压能力”，也有说是考察计算机思维的（比如分治、时空权衡、递归）。倾向于“考察计算机思维”这个答案。

> 【扩展问题】有兴趣的可以尝试微改代码，让程序能输出所有解法。（其实只需改一行代码）

就这个问题本身，有两组解，除了我开头说的那种之外，剩下这种给我一种很“机器人”的感觉hhh：它是借助7L容器来构造1L进而构造9L（因为10-1=9嘛），然后9-7=2，构造出2，再然后……

```
Found out solution:
[(Total=10, water=10)	(Total=7, water=0)	(Total=3, water=0)]
[(Total=10, water=3)	(Total=7, water=7)	(Total=3, water=0)]
[(Total=10, water=3)	(Total=7, water=4)	(Total=3, water=3)]
[(Total=10, water=6)	(Total=7, water=4)	(Total=3, water=0)]
[(Total=10, water=6)	(Total=7, water=1)	(Total=3, water=3)]
[(Total=10, water=9)	(Total=7, water=1)	(Total=3, water=0)]
[(Total=10, water=9)	(Total=7, water=0)	(Total=3, water=1)]
[(Total=10, water=2)	(Total=7, water=7)	(Total=3, water=1)]
[(Total=10, water=2)	(Total=7, water=5)	(Total=3, water=3)]
[(Total=10, water=5)	(Total=7, water=5)	(Total=3, water=0)]
```

# 附录-完整代码
完整的代码如下（两个文件）：
```C++
// state.h
#pragma once
#include <iostream>
#include <vector>

// 单个容器的状态
struct ContainerState {
  int volume;        // 容器本身的固有容积
  int water_volume;  // 容器当前储水的体积
};

// 单个结点的状态
// 温馨提示：这里用了assert是会导致程序直接退出的。若是线上服务，最好用可降级的报错方式。
struct NodeState {
  std::vector<ContainerState> states;

  bool operator==(const NodeState& other) const {
    assert(states.size() == other.states.size());  // 限制结点的容器数量必须相等，才允许比较
    for (size_t i = 0; i < states.size(); ++i) {
      assert(states[i].volume == other.states[i].volume);  // 限制容积相等的容器对齐比较
      if (states[i].water_volume != other.states[i].water_volume) return false;
    }
    return true;
  }

  bool operator<(const NodeState& other) const {
    assert(states.size() > 0);                     // 限制非空状态
    assert(states.size() == other.states.size());  // 限制结点的容器数量必须相等，才允许比较
    for (size_t i = 0; i < states.size(); ++i) {
      assert(states[i].volume == other.states[i].volume);  // 限制容积相等的容器对齐比较
      if (states[i].water_volume != other.states[i].water_volume) {
        return states[i].water_volume < other.states[i].water_volume;
      }
    }
    return false;
  }

  friend std::ostream& operator<<(std::ostream& output, const NodeState& node) {
    output << '[';
    for (size_t i = 0; i < node.states.size(); ++i) {
      if (i > 0) output << '\t';
      output << "(Total=" << node.states[i].volume << ", water=" << node.states[i].water_volume << ")";
    }
    output << ']';
    return output;
  }
};
```

```C++
// solution.cpp
#include <iostream>
#include <map>
#include <queue>
#include <stack>

#include "state.h"
using namespace std;

void Solve(const NodeState& start, const NodeState& target);
void PrintSolution(const map<NodeState, NodeState>& visit_records, const NodeState& start, const NodeState& target);

int main() {
  NodeState start{.states = {{10, 10}, {7, 0}, {3, 0}}};
  NodeState target{.states = {{10, 5}, {7, 5}, {3, 0}}};
  Solve(start, target);
  return 0;
}

void Solve(const NodeState& start, const NodeState& target) {
  // 1、根据初始状态来初始化队列
  queue<NodeState> state_queue;
  state_queue.push(start);
  map<NodeState, NodeState> visit_records;

  // 2、出队、尝试转移到新的结点
  while (!state_queue.empty()) {
    // 2.1、出队
    NodeState curr_state = state_queue.front();
    state_queue.pop();

    // 2.2、尝试转移状态
    for (size_t i = 0; i < curr_state.states.size(); ++i) {
      for (size_t j = 0; j < curr_state.states.size(); ++j) {
        if (i == j) continue;                                // 自己不能倒给自己
        int self_water = curr_state.states[i].water_volume;  // 自身有的水量
        int can_accept_water = curr_state.states[j].volume - curr_state.states[j].water_volume;  // 对方可接收的水量
        int poll_water = min(self_water, can_accept_water);                                      // 本次可倒的水
        if (poll_water == 0) continue;

        NodeState new_state = curr_state;
        new_state.states[i].water_volume -= poll_water;
        new_state.states[j].water_volume += poll_water;
        // 2.3、判断是否转移到目标状态了，是则可以退出了
        if (new_state == target) {
          visit_records[new_state] = curr_state;
          PrintSolution(visit_records, start, target);
          return;
        }

        // 2.4、判断新结点是否重复，不重复才允许加入队列
        if (visit_records.find(new_state) == visit_records.end()) {
          visit_records[new_state] = curr_state;
          state_queue.push(new_state);
        }
      }
    }
  }

  // 3、队列出空还未找到有效路径，则判定为无解
  cout << "No solution..." << endl;
}

void PrintSolution(const map<NodeState, NodeState>& visit_records, const NodeState& start, const NodeState& target) {
  NodeState curr_state = target;
  stack<NodeState> solution;
  while (true) {
    solution.push(curr_state);
    if (curr_state == start) break;
    auto iter = visit_records.find(curr_state);
    // 注：这里一定能反推回去，除非代码写错了
    if (iter == visit_records.end()) {
      cout << "backtrace solution fail, your code is wrong..." << endl;
      exit(-1);
    } else {
      curr_state = iter->second;
    }
  }

  cout << "Found out solution:" << endl;
  while (!solution.empty()) {
    cout << solution.top() << endl;
    solution.pop();
  }
}
```